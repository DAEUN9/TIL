### 상속

- 자손 클래스는 조상 클래스의 모든 멤버를 상속받는다
  - (단, 생성자와 초기화 블럭은 상속되지 않는다)
- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다

```java
class Parent {}
class Child extends Parent {
    // ...
}
```



### 상속 & 포함

- 상속관계 : '~은 ~이다'(is-a)
- 포함관계: '~은 ~을 가지고 있다.'(has-a)



### Object 클래스

- 모든 클래스의 조상



### 오버라이딩

- 상속받은 메서드의 내용을 변경
- 조건
  1. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 불가
  2. 조상 클래스의 메서드보다 많은 수의 예외 선언 불가
  3. 선언부가 조상 클래스의 메서드와 일치



### 참조변수 super

- 자손 클래스에서 조상 클래스로부터 상송받은 멤버를 참조하는데 사용되는 참조변수
- this처럼 super를 붙여서 구분

```java
super.변수
```



### super() - 조상의 생성자

- 생성자는 상속되지 않는다



### 패키지

- 클래스의 묶음
- 물리적으로 하나의 디렉토리
- 선언 - 반드시 첫번째 문장

```java
package 패키지명;
```



### 클래스 패스

- PakageTest클래스가 com.codechobo.book패키지에 포함되어 있다면 클래스 파일인 PackageTest.class는 아래의 그림과 같이 com폴더 안의 codechobo폴더 안의 book폴더 안에 있어야 한다.
- 패키지의 루트 디렉토리를 클래스패스에 포함시켜야함
- 제어판-시스템-고급 시스템 설정-환경변수-새로 만들기
  - 변수이름에 CLASSPATH입력, 변수 값에는 디렉토리 com의 상위 디렉토리 입력



### import 문

```java
import 패키지명.클래스명;
// 또는
import 패키지명.*;
```



### static import 문

- static멤버를 호출할 때 클래스 이름 생략 가능



### 제어자

- 접근 제어자: public, protected, (default), private
- 그 외: static, final, abstract, native, transient...



### static - 클래스의, 공통적인

- 멤벼변수, 메서드, 초기화 블럭에서 사용



### final - 마지막의, 변경될 수 없는

- 클래스, 메서드, 멤버변수, 지역변수에서 사용
- 값을 변경할 수 없는 상태가 됨
- 메서드에 사용하면 오버라이딩을 할 수 없음
- 클래스에 사용하면 자손클래스 정의 못함



### abstract - 추상의, 미완성의

- 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드 선언
- 클래스, 메서드에서 사용
- 추상 클래스는 추상 메서드를 포함한 클래스



### 접근 제어자

| 제어자    | 같은 클래스 | 같은 패키지 | 자손클래스 | 전 체 |
| --------- | ----------- | ----------- | ---------- | ----- |
| public    | O           | O           | O          | O     |
| protected | O           | O           | O          |       |
| (default) | O           | O           |            |       |
| private   | O           |             |            |       |



### 다형성

- 여러 가지 형태를 가질 수 잇는 능력
- 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 함
- 자손타입의 참조변수로 조상타입의 인스턴스 참조 불가



### 참조변수의 형변환

- 서로 상속관계에 있는 타입간의 형변환은 양방향 자유
- 조상타입을 자손타입으로 형변환하는 경우 생략 불가
- 참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용x



### instanceof 연산자

- 연산결과 boolean
- 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용
- `A instanceof B`
- 어떤 타입에 대한 연산 결과가 true면 검사한 타입으로 형변환 가능



### 매개변수의 다양성

- 매개변수가 Product타입의 참조변수라는 것은 메서드의 매개변수로 Product클래스의 자손타입의 참조변수면 어느 것이나 매개변수로 받아들일 수 있다는 뜻

```java
void buy(Product p){
    money -= p.price;
    bonusPoint += p.bonusPoint;
}
```



### Vector 클래스

- 동적으로 크기가 관리되는 객체배열

```java
public class Vector extends AbstractList
    implements List, Cloneable, java.io.Serializable{
    protected Object elementData[];
}
```



### 추상 클래스

- 미완성 메서드를 포함하고 있는 클래스

```java
abstract class 클래스이름 {
    ...
}
```



### 추상 메서드

- 선언부만 작성, 구현부는 작성 x
- 추상클래슬르 상속받는 자손클래슨느 오버라이딩으로 추상메서드 모두 구현해야 함
  - 하나라도 구현하지 않는다면 자손클래스 역시 추상클래스로 지정

```java
abstract 리턴타입 메서드이름();
```



### 인터페이스

- 추상클래스보다 추상화 정도가 높음
- 클래스처럼 접근제어자로 public 또는 default만 사용

```java
interface 인터페이스이름 {
    public static final 타입 상수이름 = 값;
    public abstract 메서드이름(매개변수목록);
}
```

- 인터페이스 멤버 제약사항
  - 모든 멤버변수는 public static final 이어야 하며, 생략가능
  - 모든 메서드는 public abstract 이어야 하며, 생략가능
    - 단, static메서드와 디폴트 메서드는 예외(JDK1.8부터)



### 인터페이스의 상속

- 다중상속 가능



### 인터페이스의 구현

- 그 자체로는 인스턴스 생성 불가

```java
class 클래스이름 implements 인터페이스이름 {
    // 인터페이스에 정의된 추상메서드를 모두 구현해야 한다
}
```

- 구현하는 인터페이스의 메서드 중 일부만 구현한다면 abstract를 붙여서 추상클래스로 선언



### 인터페이스를 이용한 다형성

- 해당 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 다시 참조 가능
- 인터페이스 타입으로 형변환 가능
- 인터페이스 Fightable을 클래스 Fighter가 구현했을 때, 다음과 같이 Fighter인스턴스를 Fightable타입의 참조변수로 참조하는 것 가능

```java
Fightable f = (fightable)new Fighter();
// 또는
Fightable f = new Fighter();
```

- 메서드의 매개변수 타입으로도 사용 가능
- 리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미



### 인터페이스 장점

- 개발시간 단축
- 표준화 가능
- 서로 관계없는 클래스들에게 관계 맺어 줄 수 있음
- 독립적인 프로그래밍 가능



### 디폴트 메서드와 static메서드

- 디폴트 메서드: 추상 메서드의 기본적인 구현을 제공하는 메서드. 추상메서드가 아님

  - 앞에 키워드 default 붙임
  - 몸통 `{}`이 있어야함
  - 접근 제어자가 public이며 생력가능

- 새로 추가된 디폴트 메서드가 기존의 메서드와 이름이 중복되어 충돌한는 경우 해결 규칙

  1. 여러 인터페이스의 디폴트 메서드 간의 충돌
     - 인터페이스를 구현한 클래스에서 디폴트 메서드 오버라이딩

  2. 디폴트 메서드와 조상 클래스의 메서드 간의 충돌
     - 조상 클래스의 메서드가 상속되고, 디폴트 메서드는 무시



### 내부 클래스

- 클래스 내에 선언된 클래스
- 장점
  - 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근
  - 코드의 복잡성을 줄일 수 있다(캡슐화)



### 내부 클래스의 종류와 특징

| 내부 클래스     | 특징                                                         |
| --------------- | ------------------------------------------------------------ |
| 인스턴스 클래스 | - 외부 클래스의 멤버변수 선언위치에 선언<br />- 외부 클래스의 인스턴스멤버처럼 다루어짐<br />- 주로 외부 클래스의 인스턴스멤버들과 관련된 작업에 사용 |
| 스태틱 클래스   | - 외부 클래스의 멤버변수 선언위치에 선언<br />- 외부 클래스의 static멤버처럼 다루어짐<br />- 주로 외부 클래스의 static 멤버, 특히 static 메서드에 사용 |
| 지역 클래스     | - 외부 클래스의 메서드나 초기화블럭 안에 선언<br />- 선언된 영역 내부에서만 사용 |
| 익명 클래스     | - 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용) |



### 내부 클래스의 제어자와 접근성

- 내부 클래스도 abstract나 final과 같은 제어자 사용 가능
- 멤버변수들처럼 private, protected과 접근제어자도 사용 가능



### 익명 클래스

- 이름이 없다
- 클래스의 선언과 객체의 생성을 동시에 하고 일회용

```java
new 조상클래스이름() {
    // 멤버선언
}

// 또는

new 구현인터페이스이름() {
    // 멤버선언
}
```

- 생성자 가질 수 없음
- 하나의 클래스로 상속받는 동시에 인터페이스를 구현하거나 둘 이상의 인터페이스 구현 불가
- 오로지 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만 구현